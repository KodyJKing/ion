(function(){require.register('ion/reactive/Operation',function(module,exports,require){// Generated by CoffeeScript 1.6.3
(function() {
  var Construct, Operation, key, ops, properties;

  Construct = require('./Construct');

  module.exports = Operation = (function() {
    function Operation(properties) {
      Object.merge(this, properties);
    }

    Operation.prototype.format = function _format(a, b) {
      return "" + a + " " + this.op + " " + b;
    };

    Operation.prototype.toString = function _toString() {
      return this.op;
    };

    Operation.prototype.runtime = './OperationExpression';

    Operation.prototype.createRuntime = function _createRuntime(context, args) {
      var type;
      type = require(this.runtime);
      return new type({
        operation: this,
        context: context,
        args: args
      });
    };

    return Operation;

  })();

  ops = {
    "value": {
      statement: true
    },
    "block": {
      runtime: './BlockStatement'
    },
    ":": {
      runtime: './AssignmentStatement'
    },
    "if": {
      statement: true
    },
    "for": {
      statement: true
    },
    "=": {
      statement: true
    },
    "ref": {},
    "children": {},
    "call": {},
    "array": {},
    "object": {},
    "predicate": {
      newContext: true,
      runtime: './NewContextExpression',
      evaluate : function _evaluate(left, right) {
        if (right) {
          return left;
        } else {
          return void 0;
        }
      }
    },
    "local": {
      newContext: true,
      runtime: './NewContextExpression',
      evaluate : function _evaluate(left, right) {
        return right;
      }
    },
    "member": {
      newContext: true,
      runtime: './NewContextExpression',
      observeLeftValue: true,
      evaluate : function _evaluate(left, right) {
        var value;
        value = left != null ? left[right] : void 0;
        if (typeof value === 'function') {
          value = value.bind(left);
        }
        return value;
      }
    },
    "*": {
      evaluate : function _evaluate(left, right) {
        return left * right;
      }
    },
    "/": {
      evaluate : function _evaluate(left, right) {
        return left / right;
      }
    },
    "%": {
      evaluate : function _evaluate(left, right) {
        return left % right;
      }
    },
    "+": {
      evaluate : function _evaluate(left, right) {
        return left + right;
      }
    },
    "-": {
      evaluate : function _evaluate(left, right) {
        return left - right;
      }
    },
    "&&": {
      evaluate : function _evaluate(left, right) {
        return left && right;
      }
    },
    "||": {
      evaluate : function _evaluate(left, right) {
        return left || right;
      }
    },
    "root": {
      evaluate : function _evaluate() {
        var _ref, _ref1;
        return (_ref = (_ref1 = this.parent) != null ? _ref1["this"] : void 0) != null ? _ref : this["this"];
      }
    },
    "ancestor": {
      evaluate : function _evaluate(delta) {
        var context;
        context = this;
        while (delta > 0 && (context != null)) {
          context = context.parent;
          delta--;
        }
        return context["this"];
      }
    }
  };

  for (key in ops) {
    properties = ops[key];
    properties.op = key;
    Operation[key] = new Operation(properties);
  }

  Operation.createRuntimes = function _createRuntimes(context, astArray) {
    return astArray.map(function(arg) {
      return Operation.createRuntime(context, arg);
    });
  };

  Operation.createRuntime = function _createRuntime(context, ast) {
    var op, operation;
    op = ast != null ? ast.op : void 0;
    if (op == null) {
      return new (require('./StaticExpression'))({
        value: ast
      });
    }
    operation = Operation[op];
    if (operation == null) {
      throw new Error("Operation not found " + op);
    }
    return operation.createRuntime(context, ast.args);
  };

}).call(this);

})})()