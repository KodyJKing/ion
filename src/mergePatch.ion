const
    ion = import './'
    isObject = (a) ->
        let type = typeof a
        return a? and type is 'object' or type is 'function'
    deleteValue = null
    isPrivate = (name) -> name[0] is '_'
    watchImmediate = (object, handler) ->
        if not isObject(object)
            throw new Error("Cannot watch: #{object}")
        watch.count = (watch.count ? 0) + 1
        # watch.objects ?= []
        # watch.objects.push(object)
        let watching = true
        let propertyWatchers = {}
        let watchProperties = (changes) ->
            let properties = changes?.map((a) -> a.name) ? Object.keys(object)
            for name in properties
                do (name) ->
                    if watching
                        propertyWatchers[name]?()
                        let value = object[name]
                        if isObject(value)
                            propertyWatchers[name] = watch(
                                value
                                (patch) ->
                                    # console.log('WATCH PROPERTIES ' + JSON.stringify({[name]:patch}))
                                    handler({[name]:patch})
                            )
                        else
                            delete propertyWatchers[name]

        watchProperties(null)
        let unobserve = ion.observe(
            object
            (changes) ->
                if watching
                    let patch = null
                    for {name} in changes
                        # we ignore names that start with underscore, they are considered private
                        if not isPrivate(name)
                            patch ?= {}
                            # we convert undefined values from delete into explicit nulls
                            patch[name] = object.hasOwnProperty(name) ? object[name] : deleteValue
                    watchProperties(changes)
                    if patch?
                        # console.log('OBSERVE ' + JSON.stringify(patch))
                        handler(patch)
        )
        return ->
            watch.count--
            # watch.objects.remove(object)
            watching = false
            unobserve()
            unobserve = null
            for key, unwatch of propertyWatchers
                unwatch()
            propertyWatchers = null
    increment = /[+-]\d+/

export const
    canSetProperty = (object, key) -> not (typeof object is 'function' and key is 'name')
    # options:
    #   deleteNull: delete properties if value is null, default: true
    #   factory: function to use when constructing new objects, defaults to using plain objects {}
    merge = (target, values, options, schema) ->

        if schema?.type is 'integer' and increment.test(values)
            values = (typeof target is 'number' ? target : 0) + parseInt(values.substring(1))

        let deleteNull = options?.deleteNull ? true
        if values?.constructor isnt Object
            return values
        if not isObject(target)
            if options?.factory?
                target = options.factory(values)
            else
                target = {}
        for key, value of values
            if deleteNull and value is deleteValue
                delete target[key]
                ion.changed(target)
            else
                let itemSchema = schema?.items ? schema?.properties?[key]
                let newValue = merge(target[key], value, options, itemSchema)
                if newValue isnt target[key] and canSetProperty(target, key)
                    target[key] = newValue
                    # console.log('*****patch*********')
                    ion.changed(target)
        return target
    # combines two patches to make a single patch
    combine = (patch1, patch2) -> merge(patch1, patch2, {deleteNull:false})
    # watches object for changes and calls the handler with patches
    watch = (object, handler) ->
        # this version delays callbacks in order to merge all simultaneous changes
        # into a single patch object before calling the main handler
        let active = false
        let combinedPatch = undefined
        let finalCallback = ->
            handler(combinedPatch)
            active = false
            combinedPatch = undefined
        let delayedHandler = (patch) ->
            combinedPatch = combine(combinedPatch, patch)
            if not active
                ion.nextCheck(finalCallback)
                active = true
        return watchImmediate(object, delayedHandler)
    diff = (oldValue, newValue) ->
        # returns a patch which can convert from the oldValue to the newValue
        # returns undefined if there is no difference between them
        # the patch SHOULD be treated as readonly, since it may reference pre-existing objects
        if oldValue is newValue
            return undefined
        if not(oldValue? and newValue? and typeof newValue is 'object' and typeof oldValue is 'object')
            return newValue ? null
        let patch = undefined
        for name of oldValue if oldValue.hasOwnProperty(name)
            if not newValue.hasOwnProperty(name)
                patch ?= {}
                patch[name] = null
            else
                let propertyDiff = diff(oldValue[name], newValue[name])
                if propertyDiff isnt undefined
                    patch ?= {}
                    patch[name] = propertyDiff
        for name of newValue if newValue.hasOwnProperty(name) and not oldValue.hasOwnProperty(name)
            patch ?= {}
            patch[name] = newValue[name]
        return patch
    isChange = (oldValue, newValue) ->
        # returns true if a newValue will change the old value
        # returns false if a newValue will not change the old value
        if oldValue is newValue
            return false
        if not (oldValue? and newValue? and typeof newValue is 'object' and typeof oldValue is 'object')
            return true
        if Array.isArray(newValue) and JSON.stringify(oldValue) isnt JSON.stringify(newValue)
            return true
        for name of newValue
            if not oldValue.hasOwnProperty(name)
                if not newValue[name]?
                    continue
                else
                    return true
            if isChange(oldValue[name], newValue[name])
                return true
        return false
    test = do ->
        const equal = (a, b) -> not isChange(a, b) and not isChange(b, a)
        return
            merge: ->
                assert equal({a:{b:2,c:3},d:4}, merge({a:{b:2}}, {a:{c:3},d:4}))
                assert equal({b:2}, merge(null, {b:2}))
                assert equal({a:1,b:2}, merge({a:1,b:2,c:3}, {c:undefined}))
                let double = (x) -> x * 2
                assert equal({a:double}, merge({},{a:double}))
                assert equal({a:[]}, merge({a:[1,2]}, {a:[]}))
            isChange: ->
                assert isChange({a:1}, null)
                assert not isChange(null, null)
                assert isChange(undefined, null)
                assert isChange(null, undefined)
                assert not isChange({a:1}, {a:1})
                assert not isChange({a:{b:2,c:3}}, {a:{b:2}})
                assert isChange({a:{b:2}}, {a:{b:3}})
                assert not isChange({a:1}, {b:null})
                assert isChange({a:[1,2]}, {a:[]})
            diff: ->
                assert equal({b:2}, diff({a:1}, {a:1,b:2}))
                assert equal({a:{b:3,c:null}}, diff({a:{b:2,c:4}}, {a:{b:3}}))
                assert equal({a:1}, diff(null, {a:1}))
                assert equal({c:{d:{f:4}}}, diff({a:1,b:2,c:{d:{e:1,f:2}}}, {a:1,b:2,c:{d:{e:1,f:4}}}))
                assert equal(null, diff({a:1}, undefined))
                assert equal(null, diff({a:1}, null))
                assert equal(undefined, diff({a:{b:2}}, {a:{b:2}}))
            observe: (done) ->
                # console.log('>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>')
                let source =
                    name: 'Kris'
                    age: 41
                    children: 
                        Sadera:
                            grandchildren:
                                One: 1
                                Two: 2
                        Orion: {}
                        Third: {}
                let target = ion.clone(source, true)
                let unwatch = watch(
                    source
                    (patch) ->
                        # console.log("........... " + JSON.stringify(patch))
                        target = merge(target, patch)
                        # should be immediate assert
                        if equal(source, target)
                            done()
                            unwatch()
                )
                source:
                    name: 'Fred'
                    children:
                        Orion:
                            a: 1
                            b: 2
                            c: 12
                        Sadera:
                            grandchildren:
                                three: 3
                # todo: delete a property in a literal?
                delete source.children.Third
                # temp requirement
                ion.checkForChanges()
                # console.log('<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<')
