# don't depend on ion for this.

const MapShim(pairs) ->
    let lookup = {}
    let keys = []
    let uniqueCounter = 0
    const idName = "__Map_id"
    const getId = (key) ->
        if not key?
            return String(key)
        if typeof key is 'string' or typeof key is 'number' or typeof key is 'boolean'
            return "_" + key
        let id = key[idName]
        if not id?
            id = ++uniqueCounter
            Object.defineProperty(key, idName, {value:id})
        return id
    const methods =
        get: get(key) -> lookup[getId(key)]
        set: set(key, value) ->
            let id = getId(key)
            if not lookup.hasOwnProperty(id)
                keys.push(key)
            lookup[id] = value
            return value
        has: has(key) -> lookup.hasOwnProperty(getId(key))
        delete: del(key) ->
            let id = getId(key)
            keys.remove(key)
            delete lookup[id]
        clear: clear ->
            lookup = {}
        keys: -> keys.slice(0)
        forEach: forEach (callback, thisArg) ->
            for key in keys
                let value = @get(key)
                callback.call(thisArg, value, key, @)
    for key, value of methods
        Object.defineProperty(@, key, {value})
    if pairs?
        for [key, value] in pairs
            @set(key, value)

# we will even replace Googles crap implementation of Map that doesn't yet have forEach or keys
if not global.Map?.prototype.forEach?
    global.Map = MapShim

export const test = ->
    const Map = MapShim
    let map = new Map([['a', 1], ['b', 2]])
    assert Object.keys(map).length is 0
    assert map.has('a')
    assert not map.has('c')
    assert map.get('a') is 1
    assert map.get('b') is 2
    assert map.get('c') is undefined
    let mykey1 = {}
    map.set(mykey1, "one")
    assert Object.keys(mykey1).length is 0
    assert map.get(mykey1) is "one"
    assert JSON.stringify(map.keys()) is JSON.stringify(['a','b',mykey1])
