
const clone = (object, properties) ->
    if properties?
        return {}
            for key of properties
                [key]: object[key]
    else
        return {}
            for key, value of object
                [key]: value

export const createShim = ->
    # multiple callbacks on same object.
    let map = new Map()
    let observers = []

    let observe = (object, callback, property) ->
        # console.log('+observe', property)
        let meta = map.get(object)
        if not meta?
            meta =
                object: object
                properties: {}
                all: 0
                clone: clone(object, property ? {[property]:0} : null)
                callbacks: []
            map.set(object, meta)
            observers.push(meta)
        if property?
            meta.properties[property] ?= 0
            meta.properties[property]++
        else
            meta.all++
        meta.callbacks.push(callback)
    let unobserve = (object, callback, property) ->
        # console.log('-unobserve', object, callback)
        let meta = map.get(object)
        if meta?
            let index = meta.callbacks.lastIndexOf(callback)
            if index >= 0
                meta.callbacks.splice(index, 1)
                if meta.callbacks.length is 0
                    # remove no longer observed objects
                    map.delete(object)
                    observers.splice(observers.lastIndexOf(meta), 1)
            if property?
                meta.properties[property]--
                if meta.properties[property] is 0
                    delete meta.properties[property]
            else
                meta.all--

    let getChanges = (oldValue, newValue, properties) ->
        let changes = null
        let change = (type, name, oldValue) ->
            changes ?= []
            changes.push({type,name,oldValue})
            # console.log('change', type, name)
        let checkForChange = (property) ->
            # we only check add/delete on plain old javascript objects
            if newValue.constructor is Object
                if oldValue.hasOwnProperty(name)
                    let oldPropertyValue = oldValue[name]
                    if not newValue.hasOwnProperty(name)
                        if oldPropertyValue isnt undefined
                            change("delete", name, oldPropertyValue)
                    else
                        let newPropertyValue = newValue[name]
                        if newPropertyValue isnt oldPropertyValue
                            change("update", name, oldPropertyValue)
                else if newValue.hasOwnProperty(name)
                    change("add", name)
            else
                # for everything else, we only check current property values
                let oldPropertyValue = oldValue[name]
                let newPropertyValue = newValue[name]
                if newPropertyValue isnt oldPropertyValue
                    change("update", name, oldPropertyValue)

        if properties?
            for name of properties
                checkForChange(name)
        else
            for name of oldValue
                checkForChange(name)
            for name of newValue
                if not oldValue.hasOwnProperty(name)
                    checkForChange(name)
        return changes
    observe.checkForChanges = ->
        let maxCycles = 10
        # we have to run multiple cycles in case callbacks cause further change propagation
        for let i = 0; i < maxCycles; i++
            let totalChanges = 0
            let pendingChanges = []
            # traverse all objects and find changes
            for meta in observers
                let properties = meta.all > 0 ? null : meta.properties
                let changes = getChanges(meta.clone, meta.object, properties)
                if changes?
                    totalChanges++
                    meta.clone = clone(meta.object, properties)
                    # callbacks must be deferred until after ALL changes have been found
                    pendingChanges.push([changes, meta.callbacks.slice(0), meta])
            if totalChanges is 0
                return
            for [changes, callbacks] in pendingChanges
                # console.log(i, changes)
                for callback in callbacks
                    callback(changes)

        # we have hit max cycles, indicates a circular dependency error
        throw new Error("Circular Object.observe dependency")

    observe.observers = observers
    return {observe,unobserve}

export const test = ->
    let {observe,unobserve} = createShim()
    let object =
        a: 1
        b:
            c: 2
            d: 3
    let changes
    let handler = (c) ->
        changes = c
    observe(object, handler)
    object.a = 2
    delete object.b
    object.c = 5
    observe.checkForChanges()
    assert JSON.stringify(changes) is JSON.stringify([{"type":"update","name":"a","oldValue":1},{"type":"delete","name":"b","oldValue":{"c":2,"d":3}},{"type":"add","name":"c"}])
    unobserve(object, handler)

if not Object.observe? and global.Map?
    for key, value of createShim()
        Object[key] = value
