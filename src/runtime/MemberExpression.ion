const
    ion = import '../'
    {DynamicExpression,Factory} = import './'

export class MemberExpression extends DynamicExpression
    properties:
        activate: ->
            super
            @objectExpression ?= @context.createRuntime(@object)
            @propertyExpression ?= @context.createRuntime(@computed ? @property : @property.name)

            # observe the property first so it is available when we get the object
            @unobserveProperty = @propertyExpression.observe(
                @propertyWatcher ?= (propertyValue) =>
                    @propertyValue = propertyValue
                    @queueUpdate()
            )

            @unobserveObject = @objectExpression.observe(
                @objectWatcher ?= (objectValue) =>
                    @objectValue = objectValue
                    @queueUpdate()
            )

            @updateValue(true)

        deactivate: ->
            super
            @unobserveObject?()
            @unobserveObject = null
            @unobserveProperty?()
            @unobserveProperty = null
            @unobserveObjectValue?()
            @unobserveObjectValue = null
        queueUpdate: ->
            ion.nextTick(this.updateValue.bind(this))
        updateValue: (force) ->
            let value = undefined
            if @objectValue?
                if @propertyValue?
                    value = @objectValue[@propertyValue]
            else if @isActive and not @existential and @loc?.start?.source? and @hasOwnProperty('objectValue') and @hasOwnProperty('propertyValue')
                # we need to throw an exception here with location info
                console.warn("Cannot read {{Factory.toCode(@property)}} property of {{@objectValue}} ({{Factory.toCode(@object)}}) ({{@loc.start.source}}:{{@loc.start.line}}:{{@loc.start.column + 1}})")
            @setValue(value)

            # also observe the objectValue for changes
            if @observedObject isnt @objectValue or @observedProperty isnt @propertyValue
                @observedObject = @objectValue
                @observedProperty = @propertyValue
                @unobserveObjectValue?()
                @unobserveObjectValue = null
                if @objectValue?
                    @unobserveObjectValue = ion.observe(
                        @objectValue
                        (changes) =>
                            @queueUpdate()
                        {property:@propertyValue}
                    )

        # sets the underlying property value.  This may be used for two way binding.
        setMemberValue: (value) ->
            # console.log('setMemberValue BITCHES!', @objectValue, @propertyValue, value)
            if @objectValue? and @propertyValue?
                @objectValue[@propertyValue] = value
    test: ->
