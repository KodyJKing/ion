const
    ion = import '../'
    DynamicExpression = import './DynamicExpression'

export class MemberExpression extends DynamicExpression
    properties:
        activate: ->
            super
            @objectExpression ?= @context.createRuntime(@object)
            @propertyExpression ?= @context.createRuntime(@computed ? @property : @property.name)

            @propertyExpression.watch(
                @propertyWatcher ?= (propertyValue) =>
                    @propertyValue = propertyValue
                    @updateValue()
            )

            @objectExpression.watch(
                @objectWatcher ?= (objectValue) =>
                    @objectValue = objectValue
                    @updateValue()
            )
        deactivate: ->
            super
            @objectExpression.unwatch(@objectWatcher)
            @propertyExpression.unwatch(@propertyWatcher)
        updateValue: ->
            let value = undefined
            if @objectValue? and @propertyValue?
                value = @objectValue[@propertyValue]
            @setValue(value)

            # also observe the objectValue for changes
            if @observedObject isnt @objectValue or @observedProperty isnt @propertyValue
                @observedObject = @objectValue
                @observedProperty = @propertyValue
                @objectObserver?()
                if @objectValue?
                    @objectObserver = ion.observe(
                        @objectValue
                        (changes) =>
                            @updateValue()
                        @propertyValue
                    )

        # sets the underlying property value.  This may be used for two way binding.
        setMemberValue: (value) ->
            # console.log('setMemberValue BITCHES!', @objectValue, @propertyValue, value)
            if @objectValue? and @propertyValue?
                @objectValue[@propertyValue] = value
