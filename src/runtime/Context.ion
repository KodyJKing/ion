
const
    ion = import '../'
    Factory = import './Factory'
    Literal = import './Literal'
    noop = ->

export class Context
    constructor: (parent, output) ->
        # the output object that values are written to
        @output = output
        # parent is either null or another Context
        @parent = parent
        # an object that maps variable names to variable expressions
        @variables = {}
        # store a reference to the root context
        @root = @parent?.root ? @
        # track which variables we have watched for get property
        @_watched = {}
        # runtime nodes keyed by toCode
        @_runtimes = {}
    properties:
        newContext: (output = @output) -> new Context(@, output)
        createRuntime: (node) ->
            # if Factory.canCache(node)
            #     let key = Factory.toCode(node)
            #     if @_runtimes.hasOwnProperty(key)
            #         return @_runtimes[key]
            #     else
            #         console.log('caching: ' + Factory.toCode(node))
            #         return @_runtimes[key] = Factory.createRuntime(@, node)
            # else
            return Factory.createRuntime(@, node)
        get: (name) ->
            let variable = @getVariable(name)
            if not variable?
                throw new Error("Variable not found: '{{name}}'")
            return variable.value
        getVariable: (name) ->
            let context = @, value
            while context?
                let variable = context.variables[name]
                if variable?
                    return variable
                context = context.parent
            # if the variable is not defined by us then it is probably a global variable.
            # we do however require that it be a globally defined variable, otherwise we throw an error.
            value = global[name]
            if value is undefined
                throw new Error("Variable not found: '{{name}}'")
            # global values are considered to be constants.
            # we could consider caching these values within the context.
            let cachedGlobals = @root.globals ?= {}
            return cachedGlobals[name] ?= new Literal({value})
        setVariableFromAst: (name, node) ->
            if name?
                @setVariableExpression(name, @createRuntime(node))
        setVariableLiteral: (name, value) ->
            if name?
                @setVariableExpression(name, new Literal({value}))
        setVariableExpression: (name, expression) ->
            if name?
                # we always watch the expression to make sure it is created only once
                # if we don't, then it may be created and destroyed multiple times which can cause bugs
                expression.watchValue(noop)
                return @variables[name] = expression
