
const
    ion = import '../'
    Factory = import './Factory'
    Literal = import './Literal'
    noop = ->

const createArrayInserter = (container) ->
    let baseLength = container.length
    let insertionOrders = []
    let insertionValues = {}
    let pendingOrderChanges = {} # oldOrder => newOrder

    let insertInternal = (value, order, fastInsert) ->
        if insertionValues[order]?
            throw new Error("Cannot add a new item with the same order as an existing item: {{JSON.stringify({order,previousValue:insertionValues[order],newValue:value})}}")
        insertionValues[order] = value
        insertionOrders.push(order)
        if fastInsert
            container.push(value)
        else
            insertionOrders.sort()
            let index = insertionOrders.indexOf(order)
            container.splice(baseLength + index, 0, value)
            # console.log('----- slow inserter -----> ' + order, value)
    let removeInternal = (value, order) ->
        # order MAY change during reactive runtime, so we may have to look it back up
        if insertionValues[order] isnt value
            # then we must find the new order for this value... this could be a fucking big bug source IF our values are equivalent primitives
            order = null
            for key, insertedValue of insertionValues
                if insertedValue is value
                    order = key
                    break
            if order is null
                throw new Error("Could not find value in insertionValues " + value)

        let index = insertionOrders.indexOf(order)
        if index < 0
            throw new Error("Insertion order {{JSON.stringify(order)}} not found {{JSON.stringify(insertionOrders)}}")
        # console.log('remove: ' + JSON.stringify({value,index,insertionOrders,container}))
        # remove from insertionOrder
        insertionOrders.splice(index, 1)
        # remove from container at baseLength plus index
        container.splice(baseLength + index, 1)
        # delete from insertion values
        delete insertionValues[order]

    return
        insert: (value, order, fastInsert) ->
            insertInternal(value, order, fastInsert)
            return -> removeInternal(value, order)
        update: (oldOrder, newOrder) ->
            if oldOrder? and newOrder?
                pendingOrderChanges[oldOrder] = newOrder
            else
                # console.log("======> APPLY PENDING ORDER CHANGES: {{JSON.stringify(pendingOrderChanges)}}")

                let reinsertValues = {}
                # console.log("==================== BEGIN {{oldOrder}} -> {{newOrder}}")
                for let i = insertionOrders.length - 1; i >= 0; i--
                    # console.log(">>> " + JSON.stringify({i,insertionOrders}))
                    let order = insertionOrders[i]
                    for oldOrderValue, newOrderValue of pendingOrderChanges
                        if order.startsWith(oldOrderValue)
                            # console.log('------ REMOVING ' + JSON.stringify({order, oldOrder:oldOrderValue, newOrder:newOrderValue}))
                            let insertedValue = insertionValues[order]
                            reinsertValues[newOrderValue + order.substring(oldOrderValue.length)] = insertedValue
                            removeInternal(insertedValue, order)

                # new re-add changed values
                for order, value of reinsertValues
                    # console.log('+++++++ READDING ' + JSON.stringify({order}))
                    insertInternal(value, order)
                # console.log('==================== END')

const createDefaultInserter = (container) ->
    return
        insert: (value, order, fastInsert) ->
            return ion.add(container, value)
        update: (oldOrder, newOrder) ->
const createInserter = (container) ->
    if Array.isArray(container)
        return createArrayInserter(container)
    else
        return createDefaultInserter(container)

export class Context
    constructor: (parent, output, order) ->
        # the output object that values are written to
        @output = output
        # parent is either null or another Context
        @parent = parent
        # calculate and set the depth
        @depth = parent? ? parent.depth + 1 : 0
        # an object that maps variable names to variable expressions
        @variables = {}
        # store a reference to the root context
        @root = parent?.root ? @
        # runtime nodes keyed by toCode
        @_runtimes = {}
        # if there is a return expression, copy it
        @returnExpression = parent?.returnExpression
        # if this is a new output object then create a new list of objects inserted into output object
        # they are keyed by order string
        @inserter = output is parent?.output ? parent?.inserter : createInserter(output)
        @order = order
    properties:
        newContext: (output = @output, order) -> new Context(@, output, order)
        createRuntime: (node) ->
            return Factory.createRuntime(@, node)
        setFastInsert: (value) ->
            @inserter.fastInsert = value
        order:
            get: ->
                let value = @_order ? ""
                if @output? and @output is @parent?.output
                    value = @parent.order + value
                return value
            set: (value) ->
                let _order = @_order
                let oldValue = @order
                @_order = value ? ""
                let newValue = @order
                if _order? and newValue isnt oldValue
                    @inserter.update(oldValue, newValue)
        insert: (value, order) ->
            order = @order + (order ? "")
            return @inserter.insert(value, order, @inserter.fastInsert)
        get: (name) ->
            let variable = @getVariable(name)
            if not variable?
                throw new Error("Variable not found: '{{name}}'")
            return variable.value
        getVariable: (name) ->
            let context = @, value
            while context?
                let variable = context.variables[name]
                if variable?
                    return variable
                context = context.parent
            # if the variable is not defined by us then it is probably a global variable.
            # we do however require that it be a globally defined variable, otherwise we throw an error.
            value = global[name]
            if value is undefined
                throw new Error("Variable not found: '{{name}}'")
            # global values are considered to be constants.
            # we could consider caching these values within the context.
            let cachedGlobals = @root.globals ?= {}
            return cachedGlobals[name] ?= new Literal({value})
        setVariableFromAst: (name, node) ->
            if name?
                return @setVariableExpression(name, @createRuntime(node))
        setVariableLiteral: (name, value) ->
            if name?
                return @setVariableExpression(name, new Literal({value}))
        setVariableExpression: (name, expression) ->
            if name?
                if @variables[name]?
                    throw new Error("Variable {{name}} is already defined")
                # we always watch the expression to make sure it is created only once
                # if we don't, then it may be created and destroyed multiple times which can cause bugs
                @variables[name] = expression
                return expression
