const
    ion = import '../'
    Statement = import './Statement'
    DynamicExpression = import './DynamicExpression'

export class ForInOfStatement extends Statement
    properties:
        toKey: (name) ->
            if @type is 'ForOfStatement'
                return parseInt(name)
            else
                return name
        forEach: (collection, callback) ->
            # console.log('forEach', collection)
            if @type is 'ForOfStatement'
                for let key = 0; key < collection.length; key++
                    let value = collection[key]
                    callback(key, value)
            else
                for key, value of collection
                    callback(key, value)
        activate: ->
            super

            if not @statements?
                @statements = {}            
                @valueName = @left.declarations[@type is 'ForOfStatement' ? 0 : 1]?.id.name
                @keyName = @left.declarations[@type is 'ForOfStatement' ? 1 : 0]?.id.name

            # we must create new contexts for every item in the list thingy.
            # console.log('ForEachStatement.activate', @)
            @collectionExpression ?= @context.createRuntime(@right)
            (@collectionExpression.watch)
                @collectionWatcher ?= (collection) =>
                    # console.log('collectionWatcher', collection)
                    if @collection isnt collection
                        if @collection?
                            (@forEach)
                                @collection
                                (key, value) =>
                                    @removeItem(key, value)
                            ion.unobserve(@collection, @collectionObserver)
                        @collection = collection
                        if @collection?
                            (@forEach)
                                @collection
                                (key, value) =>
                                    @addItem(key, value)
                            ion.observe(@collection, @collectionObserver ?= @applyChanges.bind(@))
        deactivate: ->
            super
            @collectionExpression.unwatch(@collectionWatcher)
        addItem: (key, value, activate = true) ->
            # console.log('add ' + key + ' ' + value)
            if value isnt undefined
                # see if there is a cached statement with that value
                let newContext = @context.newContext()
                if @valueName?
                    newContext.setVariable(@valueName, new DynamicExpression({value:value}))
                if @keyName?
                    newContext.setVariable(@keyName, new DynamicExpression({value:key}))
                let statement = newContext.createRuntime(@body)
                @statements[key] = statement
                if activate
                    statement.activate()
                return statement
        removeItem: (key, value) ->
            let statement = @statements[key]
            # console.log('remove ' + key + ' ' + value + ' ', statement)
            if statement?
                @disposeStatement(statement)
            delete @statements[key]
            return statement
        disposeStatement: (statement) ->
            # see if there is a remove function to call
            if @remove?
                let removeStatement = statement.context.createRuntime(@remove)
                removeStatement.activate()
            statement.deactivate()
        applyChanges: (changes) ->
            let ignoreProperty = (name) =>
                if not name?
                    return true
                if name[0] is '_'
                    return true
                if name is 'length' and @type is 'ForOfStatement'
                    return true
                return false
            # this will be an N performance algorithm for ARRAY insertions/deletions.
            # we can improve this later by looking for "slice" events and seeing if index is not relevant.
            # console.log('changes', changes)
            let recyclableStatements = new Map
            let getRecycleKey = (key, value) => @type is 'ForOfStatement' ? value : key
            let activateStatements = []

            for {name,oldValue} in changes if not ignoreProperty(name)
                let key = @toKey(name)
                if oldValue isnt undefined
                    let rkey = getRecycleKey(key, oldValue)
                    let statement = @statements[key]
                    recyclableStatements.set(rkey, statement)

            for {name,oldValue} in changes if not ignoreProperty(name)
                let newValue = @collection[name]
                let key = @toKey(name)
                if newValue isnt undefined
                    let rkey = getRecycleKey(key, newValue)
                    let statement = recyclableStatements?.get(rkey)
                    # let statement = null
                    if statement?
                        if @type is 'ForOfStatement'
                            if @keyName?
                                statement.context.variables[@keyName].setValue(key)
                        else
                            if @valueName?
                                statement.context.variables[@valueName].setValue(newValue)
                        recyclableStatements.delete(rkey)
                    else
                        statement = @addItem(key, newValue, false)
                        if statement?
                            activateStatements.push(statement)

            # it's important that old statements are deactivated BEFORE new statements are activated

            # recyclableStatements are deactivated.
            for key in recyclableStatements.keys()
                let statement = recyclableStatements.get(key)
                @disposeStatement(statement)

            # activate new statements
            for statement in activateStatements
                statement.activate()

