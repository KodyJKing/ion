const
    ion = import '../'
    DynamicExpression = import './DynamicExpression'
    ArrayExpression = import './ArrayExpression'

module.exports = class CallExpression extends DynamicExpression
    properties:
        args: null
        activate: ->
            super
            @calleeExpression ?= @context.createRuntime(@callee)
            (@calleeExpression.watch)
                @calleeWatcher ?= (value) =>
                    @calleeValue = value
                    # get thisArg and watch for changes
                    let thisArg = @calleeExpression.objectExpression?.value
                    if thisArg isnt @thisArg
                        ion.unobserve(@thisarg, @thisObserver)
                        @thisArg = thisArg
                        if not @calleeValue?.template # we don't need to watch the thisArg if the callee is a template
                            (ion.observe)
                                thisArg
                                @thisObserver ?= (changes) =>
                                    @evaluate()
                    @evaluate()
            @argumentExpressions ?= @context.createRuntime({type:'ArrayExpression',elements:@arguments, observeElements:not @calleeValue?.template})
            (@argumentExpressions.watch)
                @argumentWatcher ?= (value) =>
                    @argumentsValue = value
                    @evaluate()
        deactivate: ->
            super
            @calleeExpression.unwatch(@calleeWatcher)
            @argumentExpressions.unwatch(@argumentWatcher)
            if @template?
                @template.unwatch(@templateWatcher)
                @template.deactivate()
                delete @template
        evaluate: ->
            if not @isActive
                return

            let value = undefined
            if @calleeValue? and @argumentsValue?
                try
                    if @calleeValue.template
                        if @template?
                            @template.unwatch(@templateWatcher)
                        # always use new on templates
                        @template = @calleeValue.template.apply(@thisArg, @argumentsValue)
                        @template.activate()
                        @template.watch(@templateWatcher ?= @setValue.bind(@))
                    else
                        if @type is 'NewExpression'
                            # create a new with variable args
                            value = ion.create(@calleeValue, @argumentsValue)
                        else # @type is 'CallExpression'
                            value = @calleeValue.apply(@thisArg, @argumentsValue)
                        @setValue(value)
                catch e
                    # if we don't catch the errors, they might not be logged when occuring in an Object.observe callback
                    console.error(e.stack ? e)
