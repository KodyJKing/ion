const
    ion = import '../'
    {DynamicExpression,ArrayExpression,Factory} = import './'

module.exports = class CallExpression extends DynamicExpression
    properties:
        args: null
        activate: ->
            super
            @calleeExpression ?= @context.createRuntime(@callee)
            @unobserveCallee = @calleeExpression.observe(
                @calleeWatcher ?= (value) =>
                    if @isActive and not value? and not @existential and @loc?.start.source?
                        # we need to throw an exception here with location info
                        console.warn("Function is {{value}} ({{Factory.toCode(@callee)}}) ({{@loc.start.source}}:{{@loc.start.line}}:{{@loc.start.column + 1}})")
                    @calleeValue = value
                    @evaluate()
            )
            # get thisArg and observe for changes
            @unobserveCalleeObject = @calleeExpression.objectExpression?.observe(
                @thisWatcher ?= (thisArg) =>
                    if thisArg isnt @thisArg
                        @unobserveThis?()
                        @unobserveThis = null
                        @thisArg = thisArg
                        if not @calleeValue?.template # we don't need to observe the thisArg if the callee is a template
                            if @calleeExpression.objectExpression.deep or Array.isArray(thisArg)
                                # console.log('deep observe man-------------------------', thisArg, @calleeValue)
                                # deep observe
                                @unobserveThis = ion.patch.watch(
                                    thisArg
                                    @thisObserver ?= (patch) =>
                                        # console.log('deep change', patch)
                                        @evaluate()
                                )
                            else
                                # shallow observe
                                @unobserveThis = ion.observe(
                                    thisArg
                                    @thisObserver ?= =>
                                        @evaluate()
                                    {priority:@context.depth}
                                )
                        @evaluate()
            )
            @argumentExpressions ?= @context.createRuntime({type:'ArrayExpression',elements:@arguments, observeElements:not @calleeValue?.template})
            @unobserveArguments = @argumentExpressions.observe(
                @argumentWatcher ?= (value) =>
                    @argumentsValue = value
                    @evaluate()
            )
        deactivate: ->
            super
            @unobserveCallee()
            @unobserveArguments()
            @unobserveCalleeObject?()
            @unobserveTemplate?()
            @unobserveThis?()
        evaluate: ->
            if not (@isActive and @calleeValue? and @argumentsValue?)
                return
            let value = undefined
            if @calleeValue.template
                @unobserveTemplate?()
                # always use new on templates
                @template = @calleeValue.apply(@thisArg, @argumentsValue)
                @unobserveTemplate = @template.observe(@templateWatcher ?= @setValue.bind(@))
            else
                if @type is 'NewExpression'
                    # create a new with variable args
                    value = ion.create(@calleeValue, @argumentsValue)
                else # @type is 'CallExpression'
                    value = @calleeValue.apply(@thisArg, @argumentsValue)
                @setValue(value)
