const ion = null # shouldn't depend on itself

import './es6'

const
    primitive = {string:true,number:true,boolean:true,function:true}
    isPrimitive = (object) -> not object? or primitive[typeof object] or false
    normalizeProperty = (property) ->
        if typeof property is 'function'
            property =
                writable: false
                value: property
        else if isPrimitive(property) or Array.isArray(property)
            property =
                value: property

        if not property.get? and not property.set? and not property.hasOwnProperty('value')
            property.value = undefined

        if property.hasOwnProperty('value')
            property.writable ?= true

        return property
    normalizeProperties = (properties = {}) ->
        for name, property of properties
            properties[name] = normalizeProperty(property)
        return properties
    variableArgConstructs = []
        (type, a) -> new type()
        (type, a) -> new type(a[0])
        (type, a) -> new type(a[0], a[1])
        (type, a) -> new type(a[0], a[1], a[2])
        (type, a) -> new type(a[0], a[1], a[2], a[3])
        (type, a) -> new type(a[0], a[1], a[2], a[3], a[4])
        (type, a) -> new type(a[0], a[1], a[2], a[3], a[4], a[5])
        (type, a) -> new type(a[0], a[1], a[2], a[3], a[4], a[5], a[6])
        (type, a) -> new type(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7])
        (type, a) -> new type(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8])
        (type, a) -> new type(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9])

export const
    patch = import './mergePatch'
    create = (type, args) -> variableArgConstructs[args.length](type, args)
    template = (fn) ->
        fn.template = true
        return fn
    createRuntime = (ast, args) ->
        const Context = import './runtime/Context'
        const context = new Context()
        if args?
            for name, value of args
                context.setVariable(name, value)
        return context.createRuntime(ast)
    nextTick = @process?.nextTick ? (fn) -> setTimeout(fn, 0)
    clone = (object, deep = false) ->
        if object?.constructor is Object
            return {}
                for key, value of object
                    [key]: deep ? clone(value, deep) : value
        else if Array.isArray(object)
            return [deep ? clone(item, deep) : item for item in object]
        else
            return object
    observe = (object, observer, property) ->
        # property is optional
        # if object?.nodeType?
        #     console.log('observe', object, observer, property)
        if object? and observer? and Object.observe? and typeof object is 'object'
            Object.observe(object, observer)
            # watch change on dom elements
            object.addEventListener?('change', observer)
        object?.onObserved?(observer, property)
    unobserve = (object, observer, property) ->
        # property is optional
        # if object?.nodeType?
        #     console.log('unobserve', object, observer, property)
        if object? and observer? and Object.unobserve? and typeof object is 'object'
            Object.unobserve(object, observer)
            # unwatch change on dom elements
            object.removeEventListener?('change', observer)
        object?.unObserved?(observer, property)
    add = (container, item) ->
        if typeof item is 'function' and item.name.length > 0 and typeof container.addEventListener is 'function'
            container.addEventListener(item.name, item)
        else if container.nodeType is 1
            if typeof item is 'string'
                item = document.createTextNode(item)
            container.appendChild(item)
        else if container.push?
            container.push(item)
        else
            container.add(item)

        item.onAdded?(container)

        # returns a function which can be used to remove the item
        return ->
            if typeof item is 'function' and item.name.length > 0 and typeof container.addEventListener is 'function'
                container.removeEventListener(item.name, item)
            else if container.nodeType is 1
                container.removeChild(item)
            else if container.lastIndexOf? and container.removeAt?
                let index = container.lastIndexOf(item)
                if index >= 0
                    container.removeAt(index)
            else if typeof container.remove is 'function'
                container.remove(item)
            else
                remove(container, item)

            item.onRemoved?(container)
    remove = (array, item) ->
        if array?
            let index = array.lastIndexOf(item)
            if index >= 0
                array.splice(index, 1)
                return index
        return
    defineProperties = (object, properties) -> Object.defineProperties(object, normalizeProperties(properties))
    defineClass = (...definitions) ->
        const classDefinition = definitions[0]
        if definitions[1] is undefined
            # extend our base object by default unless user sets extends to null explicitly.
            definitions[1] = import './Object'
        classDefinition.super = definitions[1]
        const name = classDefinition.name ? classDefinition.id?.match(/([a-z_0-9\$]+)(\.js)?$/i)?[1]
        if not name?
            throw new Error('missing name property')
        let classFunction
        if classDefinition.hasOwnProperty('constructor')
            classFunction = classDefinition.constructor
        else if classDefinition.super?
            classFunction = eval("(function {{name}}() { {{name}}.super.apply(this, arguments); })")
        else
            classFunction = eval("(function {{name}}() {})")

        # successively merge patch the definitions onto the new class
        for let i = definitions.length - 1; i >= 0; i--
            let definition = definitions[i]
            for key, value of definition if key isnt 'test' or i is 0
                if value?.constructor is Object or Object.getOwnPropertyDescriptor(classFunction, key)?.writable isnt false
                    classFunction[key] = patch(classFunction[key], value)

        if classFunction.properties?
            defineProperties(classFunction.prototype, classFunction.properties)

        return classFunction
    get = (object, property) ->
        if not (object? and property?)
            return undefined
        if object isnt @ and typeof object.get is 'function'
            return object.get(property)
        else
            return object[property]
    set = (object, property, value, deleteUndefined = true) ->
        # console.log('ion.set', property, value)
        if object?
            if arguments.length is 2 and property?
                # set all properties
                for k, v of property
                    set(object, k, v)
                return

            if object isnt @ and typeof object.set is 'function'
                object.set(property, value)
            else if deleteUndefined and value is undefined
                delete object[property]
            else
                object[property] = value
            # we will notify an object when it is set on another object
            # if the object has an onSet 
            value?.onSet?(object, property)
        return value
    is = (instance, type) ->
        if not instance?
            return false
        if not type?
            return true
        if typeof type is 'function'
            if typeof instance.is is 'function'
                return instance.is(type)
            return instance instanceof type
        else
            return instance is type
    makeReactive = (object, activate) ->
        let observeCount = 0
        let deactivate = null
        return (Object.defineProperties)
            object
            {}
                onObserved:
                    value: ->
                        observeCount++
                        if observeCount is 1
                            deactivate = activate.call(object)
                unObserved:
                    value: ->
                        observeCount--
                        if observeCount is 0
                            deactivate?()
    test =
        defineClass: ->
            const Foo = (defineClass)
                {}
                    id: "Foo"
                    constructor: (number) ->
                        @number = number
                    properties:
                        getValue: -> @number
            assert new Foo(2).getValue() is 2
        defineProperties:
            "should allow primitive values": ->
                const object = {}
                const result = (defineProperties)
                    object
                    {}
                        f: -> "function"
                        i: 2
                        b: true
                        a: []
                        s: "hello"
                assert object is result
                assert typeof object.f is 'function'
                assert object.f() is 'function'
                assert object.i is 2
                assert object.b is true
                assert Array.isArray(object.a)
                assert object.s is 'hello'

