
const
    primitive = {string:true,number:true,boolean:true,function:true}
    isPrimitive = (object) -> not object? or primitive[typeof object] or false
    normalizeProperty = (property) ->
        if typeof property is 'function'
            property =
                writable: false
                value: property
        else if isPrimitive(property) or Array.isArray(property)
            property =
                value: property

        if not property.get? and not property.set? and not property.hasOwnProperty('value')
            property.value = undefined

        if property.hasOwnProperty('value')
            property.writable ?= true

        return property
    normalizeProperties = (properties = {}) ->
        for name, property of properties
            properties[name] = normalizeProperty(property)
        return properties
    defineProperties = (object, properties) -> Object.defineProperties(object, normalizeProperties(properties))

export const
    createRuntime = (ast, args) ->
    nextTick = @process?.nextTick ? (fn) -> setTimeout(fn, 0)
    clone = (object, deep = false) ->
        if object?.constructor is Object
            return {}
                for key, value of object
                    [key]: deep ? clone(value, deep) : value
        else if Array.isArray(object)
            return [deep ? clone(item, deep) : item for item in object]
        else
            return object
    observe = (object, observer, property) ->
        # property is optional
        if object? and observer? and Object.observe? and typeof object is 'object'
            Object.observe(object, observer)
            # watch change on dom elements
            object.addEventListener?('change', observer)
        object?.onObserved?(observer, property)
    unobserve = (object, observer, property) ->
        # property is optional
        if object? and observer? and Object.unobserve? and typeof object is 'object'
            Object.unobserve(object, observer)
            # unwatch change on dom elements
            object.removeEventListener?('change', observer)
        object?.unObserved?(observer, property)
    add = (container, item, returnRemoveFunction) ->
        if container.nodeType is 1
            if typeof item is 'string'
                item = document.createTextNode(item)
            container.appendChild(item)
        else if container.push?
            container.push(item)
        else
            container.add(item)

        item.onAdded?(container)

        if returnRemoveFunction
            # returns a function which can be used to remove the item
            return ->
                if container.nodeType is 1
                    container.removeChild(item)
                else if container.lastIndexOf? and container.removeAt?
                    let index = container.lastIndexOf(item)
                    if index >= 0
                        container.removeAt(index)
                else
                    container.remove(item)

                item.onRemoved?(container)
    defineClass = (...definitions) ->
        const classDefinition = definitions[0]
        classDefinition.super = definitions[1]
        const name = classDefinition.name ? classDefinition.id?.match(/([a-z_0-9\$]+)(\.js)?$/i)?[1]
        if not name?
            throw new Error('missing name property')
        let classFunction
        if classDefinition.hasOwnProperty('constructor')
            classFunction = classDefinition.constructor
        else
            classFunction = eval("(function {{name}}() { this.constructor.super.apply(this, arguments); })")

        # successively merge patch the definitions onto the new class
        const mergePatch = import './mergePatch'
        for let i = definitions.length - 1; i >= 0; i--
            const definition = definitions[i]
            for key, value of definition if key isnt 'test' or i is 0
                classFunction[key] = mergePatch.apply(classFunction[key], value)

        if classFunction.properties?
            defineProperties(classFunction.prototype, classFunction.properties)

        return classFunction
    test =
        defineClass: ->
            const Foo = (defineClass)
                {}
                    id: "Foo"
                    constructor: (number) ->
                        @number = number
                    properties:
                        getValue: -> @number
            assert new Foo(2).getValue() is 2
        defineProperties:
            "should allow primitive values": ->
                const object = {}
                const result = (defineProperties)
                    object
                    {}
                        f: -> "function"
                        i: 2
                        b: true
                        a: []
                        s: "hello"
                assert object is result
                assert typeof object.f is 'function'
                assert object.f() is 'function'
                assert object.i is 2
                assert object.b is true
                assert Array.isArray(object.a)
                assert object.s is 'hello'

