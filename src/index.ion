const ion = null # shouldn't depend on itself

import './es6'

const
    primitive = {string:true,number:true,boolean:true,function:true}
    isPrimitive = (object) -> not object? or primitive[typeof object] or false
    normalizeProperty = (property) ->
        if typeof property is 'function'
            property =
                writable: false
                value: property
        else if isPrimitive(property) or Array.isArray(property)
            property =
                value: property

        if not property.get? and not property.set? and not property.hasOwnProperty('value')
            property.value = undefined

        if property.hasOwnProperty('value')
            property.writable ?= true

        return property
    normalizeProperties = (properties = {}) ->
        for name, property of properties
            properties[name] = normalizeProperty(property)
        return properties
    variableArgConstructs = []
        (type, a) -> new type()
        (type, a) -> new type(a[0])
        (type, a) -> new type(a[0], a[1])
        (type, a) -> new type(a[0], a[1], a[2])
        (type, a) -> new type(a[0], a[1], a[2], a[3])
        (type, a) -> new type(a[0], a[1], a[2], a[3], a[4])
        (type, a) -> new type(a[0], a[1], a[2], a[3], a[4], a[5])
        (type, a) -> new type(a[0], a[1], a[2], a[3], a[4], a[5], a[6])
        (type, a) -> new type(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7])
        (type, a) -> new type(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8])
        (type, a) -> new type(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9])

export const
    patch = import('./mergePatch').merge
    create = (type, args) -> variableArgConstructs[args.length](type, args)
    template = (fn, template) ->
        fn.template = template
        return fn
    createRuntime = (ast, args) ->
        const Context = import './runtime/Context'
        const context = new Context()
        if args?
            for name, value of args
                context.setVariable(name, value)
        return context.createRuntime(ast)
    nextTick = @process?.nextTick ? (fn) -> setTimeout(fn, 0)
    clone = (object, deep = false) ->
        if Array.isArray(object)
            return [deep ? clone(item, deep) : item for item in object]
        else if object?.constructor is Object
            return {}
                for key, value of object
                    [key]: deep ? clone(value, deep) : value
        else
            return object
    observe = (object, observer, property) ->
        # property is optional
        # if object?.nodeType?
        #     console.log('observe', object, observer, property)
        if object? and observer? and Object.observe? and typeof object is 'object'
            Object.observe(object, observer)
            # watch change on dom elements
            object.addEventListener?('change', observer)
        object?.onObserved?(observer, property)
    unobserve = (object, observer, property) ->
        # property is optional
        # if object?.nodeType?
        #     console.log('unobserve', object, observer, property)
        if object? and observer? and Object.unobserve? and typeof object is 'object'
            Object.unobserve(object, observer)
            # unwatch change on dom elements
            object.removeEventListener?('change', observer)
        object?.unObserved?(observer, property)
    bind = (fn, thisArg) ->
        let newFn = fn.bind(thisArg)
        # the function name has semantic meaning for us when adding a function to an element
        # (see add function below)
        # so we copy the function name to the new bound function id property when binding
        # (function.name is readonly)
        if fn.name.length > 0
            newFn.id = fn.id ? fn.name
        return newFn
    add = (container, item) ->
        let remove
        if typeof item is 'function' and (item.name.length > 0 or item.id?) and typeof container.addEventListener is 'function'
            let name = item.id ? item.name
            # if this platform doesn't have native Object.observe
            # then we wrap all event handlers and call checkForChanges after
            if Object.observe?.checkForChanges?
                let originalItem = item
                item = ->
                    originalItem.apply(@, arguments)
                    Object.observe.checkForChanges()
            container.addEventListener(name, item)
            remove = ->
                container.removeEventListener(name, item)
        else if container.nodeType is 1
            if typeof item isnt 'string' and not item.nodeType?
                item = JSON.stringify(item)
            if typeof item is 'string'
                item = document.createTextNode(item)
            container.appendChild(item)
            remove = ->
                container.removeChild(item)
        else
            if container.push?
                container.push(item)
            else
                container.add(item)
            remove = ->
                if container.lastIndexOf? and container.removeAt?
                    let index = container.lastIndexOf(item)
                    if index >= 0
                        container.removeAt(index)
                else if typeof container.remove is 'function'
                    container.remove(item)
                else if Array.isArray(container)
                    let index = container.lastIndexOf(item)
                    if index >= 0
                        container.splice(index, 1)

        item.onAdded?(container)
        # returns a function which can be used to remove the item
        return ->
            remove()
            item.onRemoved?(container)
    defineProperties = (object, properties) -> Object.defineProperties(object, normalizeProperties(properties))
    defineClass = (...definitions) ->
        const classDefinition = definitions[0]
        if definitions[1] is undefined
            # extend our base object by default unless user sets extends to null explicitly.
            definitions[1] = import './Object'
        classDefinition.super = definitions[1]
        const name = classDefinition.name ? classDefinition.id?.match(/([a-z_0-9\$]+)(\.js)?$/i)?[1]
        if not name?
            throw new Error('missing name property')
        let classFunction
        if classDefinition.hasOwnProperty('constructor')
            classFunction = classDefinition.constructor
        else if classDefinition.super?
            classFunction = eval("(function {{name}}() { {{name}}.super.apply(this, arguments); })")
        else
            classFunction = eval("(function {{name}}() {})")

        # successively merge patch the definitions onto the new class
        for let i = definitions.length - 1; i >= 0; i--
            let definition = definitions[i]
            for key, value of definition if key isnt 'test' or i is 0
                if value?.constructor is Object or Object.getOwnPropertyDescriptor(classFunction, key)?.writable isnt false
                    classFunction[key] = patch(classFunction[key], value)

        if classFunction.properties?
            defineProperties(classFunction.prototype, classFunction.properties)

        return classFunction
    get = (object, property) ->
        if not (object? and property?)
            return undefined
        if object isnt @ and typeof object.get is 'function'
            return object.get(property)
        else
            return object[property]
    set = (object, property, value, deleteUndefined = true) ->
        # console.log('ion.set', property, value)
        if object?
            if arguments.length is 2 and property?
                # set all properties
                for k, v of property
                    set(object, k, v)
                return

            if object isnt @ and typeof object.set is 'function'
                object.set(property, value)
            else if deleteUndefined and value is undefined
                delete object[property]
            else
                object[property] = value
            # we will notify an object when it is set on another object
            # if the object has an onSet 
            value?.onSet?(object, property)
        return value
    is = (instance, type) ->
        if not instance?
            return false
        if not type?
            return true
        if typeof type is 'function'
            if typeof instance.is is 'function'
                return instance.is(type)
            return instance instanceof type
        else
            return instance is type
    makeReactive = (object, activate) ->
        let observeCount = 0
        let deactivate = null
        return (Object.defineProperties)
            object
            {}
                onObserved:
                    value: ->
                        observeCount++
                        if observeCount is 1
                            deactivate = activate.call(object)
                unObserved:
                    value: ->
                        observeCount--
                        if observeCount is 0
                            deactivate?()
    serialize = (object) -> JSON.stringify(object)
    deserialize = do ->
        let extractType = (object) ->
            let typeKey = import('ion/Object').typeKey
            # we should strongly type our objects when created, so make a factory
            let typeName = object[typeKey]
            if not typeName?
                return Object
            let type = import(typeName)
            if not type.serializable
                throw new Error("Type is not serializable: {{ typeName }}")
            # remove the type field from the source object
            delete object[typeKey]
            return type
        let deserialize = (object) ->
            if typeof object is 'string'
                object = JSON.parse(object)
            let typeKey = import('ion/Object').typeKey
            # we should strongly type our objects when created, so make a factory
            let typeName = object[typeKey]
            if typeName?
                let type = import(typeName)
                if not type.serializable
                    throw new Error("Type is not serializable: {{ typeName }}")
                let typedObject = new type
                for key, value of object if key isnt typeKey
                    typedObject[key] = object[key]
                return typedObject
            else
                return object
        deserialize.extractType = extractType
        return deserialize
    test =
        defineClass: ->
            const Foo = (defineClass)
                {}
                    id: "Foo"
                    constructor: (number) ->
                        @number = number
                    properties:
                        getValue: -> @number
            assert new Foo(2).getValue() is 2
        defineProperties:
            "should allow primitive values": ->
                const object = {}
                const result = (defineProperties)
                    object
                    {}
                        f: -> "function"
                        i: 2
                        b: true
                        a: []
                        s: "hello"
                assert object is result
                assert typeof object.f is 'function'
                assert object.f() is 'function'
                assert object.i is 2
                assert object.b is true
                assert Array.isArray(object.a)
                assert object.s is 'hello'

