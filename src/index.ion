
const
    primitive = {string:true,number:true,boolean:true,function:true}
    isPrimitive = (object) -> not object? or primitive[typeof object] or false
    normalizeProperty = (property) ->
        if typeof property is 'function'
            property =
                writable: false
                value: property
        else if isPrimitive(property) or Array.isArray(property)
            property =
                value: property

        if not property.get? and not property.set? and not property.hasOwnProperty('value')
            property.value = undefined

        if property.hasOwnProperty('value')
            property.writable ?= true

        return property
    normalizeProperties = (properties = {}) ->
        for name, property of properties
            properties[name] = normalizeProperty(property)
        return properties
    variableArgConstructs = []
        (type, args) -> new type()
        (type, args) -> new type(args[0])
        (type, args) -> new type(args[0], args[1])
        (type, args) -> new type(args[0], args[1], args[2])
        (type, args) -> new type(args[0], args[1], args[2], args[3])
        (type, args) -> new type(args[0], args[1], args[2], args[3], args[4])
        (type, args) -> new type(args[0], args[1], args[2], args[3], args[4], args[5])
        (type, args) -> new type(args[0], args[1], args[2], args[3], args[4], args[5], args[6])
        (type, args) -> new type(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7])
        (type, args) -> new type(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8])
        (type, args) -> new type(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9])

export const
    create = (type, args) -> variableArgConstructs[args.length](type, args)
    createRuntime = (ast, args) ->
        const Context = import './runtime/Context'
        const context = new Context()
        if args?
            for name, value of args
                context.setVariable(name, value)
        return context.createRuntime(ast)
    nextTick = @process?.nextTick ? (fn) -> setTimeout(fn, 0)
    clone = (object, deep = false) ->
        if object?.constructor is Object
            return {}
                for key, value of object
                    [key]: deep ? clone(value, deep) : value
        else if Array.isArray(object)
            return [deep ? clone(item, deep) : item for item in object]
        else
            return object
    observe = (object, observer, property) ->
        # property is optional
        if object? and observer? and Object.observe? and typeof object is 'object'
            Object.observe(object, observer)
            # watch change on dom elements
            object.addEventListener?('change', observer)
        object?.onObserved?(observer, property)
    unobserve = (object, observer, property) ->
        # property is optional
        if object? and observer? and Object.unobserve? and typeof object is 'object'
            Object.unobserve(object, observer)
            # unwatch change on dom elements
            object.removeEventListener?('change', observer)
        object?.unObserved?(observer, property)
    add = (container, item, returnRemoveFunction) ->
        if container.nodeType is 1
            if typeof item is 'string'
                item = document.createTextNode(item)
            container.appendChild(item)
        else if container.push?
            container.push(item)
        else
            container.add(item)

        item.onAdded?(container)

        if returnRemoveFunction
            # returns a function which can be used to remove the item
            return ->
                if container.nodeType is 1
                    container.removeChild(item)
                else if container.lastIndexOf? and container.removeAt?
                    let index = container.lastIndexOf(item)
                    if index >= 0
                        container.removeAt(index)
                else
                    container.remove(item)

                item.onRemoved?(container)
    defineProperties = (object, properties) -> Object.defineProperties(object, normalizeProperties(properties))
    defineClass = (...definitions) ->
        const classDefinition = definitions[0]
        if definitions[1] is undefined
            # extend our base object by default unless user sets extends to null explicitly.
            definitions[1] = import './Object'
        classDefinition.super = definitions[1]
        const name = classDefinition.name ? classDefinition.id?.match(/([a-z_0-9\$]+)(\.js)?$/i)?[1]
        if not name?
            throw new Error('missing name property')
        let classFunction
        if classDefinition.hasOwnProperty('constructor')
            classFunction = classDefinition.constructor
        else if classDefinition.super?
            classFunction = eval("(function {{name}}() { {{name}}.super.apply(this, arguments); })")
        else
            classFunction = eval("(function {{name}}() {})")

        # successively merge patch the definitions onto the new class
        const mergePatch = import './mergePatch'
        for let i = definitions.length - 1; i >= 0; i--
            const definition = definitions[i]
            for key, value of definition if key isnt 'test' or i is 0
                classFunction[key] = mergePatch.apply(classFunction[key], value)

        if classFunction.properties?
            defineProperties(classFunction.prototype, classFunction.properties)

        return classFunction
    get = (object, property) ->
        if not (object? and property?)
            return undefined
        if typeof object.get is 'function'
            return object.get(property)
        else
            return object[property]
    set = (object, property, value) ->
        # console.log 'core.set', property, value
        if object? and property?
            if typeof object.set is 'function'
                object.set(property, value)
            else if value is undefined
                delete object[property]
            else
                object[property] = value
            # we will notify an object when it is set on another object
            # if the object has an onSet 
            value?.onSet?(object, property)
        return value
    test =
        defineClass: ->
            const Foo = (defineClass)
                {}
                    id: "Foo"
                    constructor: (number) ->
                        @number = number
                    properties:
                        getValue: -> @number
            assert new Foo(2).getValue() is 2
        defineProperties:
            "should allow primitive values": ->
                const object = {}
                const result = (defineProperties)
                    object
                    {}
                        f: -> "function"
                        i: 2
                        b: true
                        a: []
                        s: "hello"
                assert object is result
                assert typeof object.f is 'function'
                assert object.f() is 'function'
                assert object.i is 2
                assert object.b is true
                assert Array.isArray(object.a)
                assert object.s is 'hello'

