const ion = import '../'

const templates = []
    []
        "regular expression"
        {}
        template (properties) ->
            return properties.name.replace(/a/g, 'b')
        {name:"alpha"}
        {}
        "blphb"
    []
        "array comprehension"
        {}
        template (properties) ->
            return [key for key of properties]
        {a:1,b:2}
        {b:undefined,c:3}
        ['a','c']
    []
        "imperative functions"
        {}
        template (properties) ->
            const double(a) -> a * 2
            return {}
                for key, value of properties
                    [key]: double(value)
        {x:1,y:2}
        {x:4,z:3,y:undefined}
        {x:8,y:4,z:6}
    []
        "for else statements"
        {}
        template (properties) ->
            return {}
                for key, value of properties
                    [key]: value
                else
                    [key]: undefined
        {x:1,y:2}
        {x:4,y:undefined,z:3}
        {x:4,z:3}
    []
        "shared variables functions"
        {}
        template (properties) ->
            let factor = properties.factor ? 3
            const multiply(a) -> a * factor
            return {}
                for key, value of properties if key isnt 'factor'
                    [key]: multiply(value)
        {x:1,y:2}
        {x:4,y:undefined,z:5,factor:10}
        {x:40,y:6,z:50}
    []
        "reactive destructured parameters"
        {}
        template ({a,b}) -> a + b
        {a:1,b:2}
        {a:5}
        7
    []
        "array comprehensions"
        {}
        template ({items}) -> [x + i for x, i in items]
        {items:[1,2,3]}
        {items:{3:4}}
        [1,3,5,7]
    []
        "changing object with function"
        {}
        template (object) -> object.sum()
        {}
            sum: -> @x + @y
            x: 1
            y: 2
        {}
            x: 6
        8
    []
        "nested templates"
        {}
        do ->
            let sum = template ({deep:{a,b}}) -> a + b
            return template (object) ->
                return sum(object.one)
        {}
            one:
                deep:
                    a: 1
                    b: 2
        {}
            one:
                deep:
                    a: 2
        4
    []
        "bidirectional properties"
        {}
        template (object) ->
            object:
                x :: object.y
            return object
        {x:1,y:2}
        {x:3}
        {x:3,y:3}
    []
        "literal objects"
        {}
        template () ->
            return {touch:1,"touch-start":2}
        {}
        {}
        {touch:1,"touch-start":2}
    []
        "this"
        let object = {x:1,y:2}
        object
        template -> this.x + this.y
        object
        {x:10}
        12
    do ->
        # this test verifies that statements are reused when a value shifts within an array
        let Type = ->
        let alpha = new Type
            name: 'alpha'
        let beta = new Type
            name: 'beta'
        let charlie = new Type
            name: 'charlie'
        let next = 0
        let nextId = -> next++
        return []
            "for in reuse values"
            {}
            template (items) ->
                return []
                    for item, index in items
                        { id: nextId(), name: item.name, index: index }
            [alpha,beta,charlie]
            {0:alpha,1:charlie,2:undefined}
            [{id:0,name:'alpha',index:0},{id:2,name:'charlie',index:1}]
    do ->
        # this test verifies that statements are reused when a value shifts within an array
        let next = 0
        let nextId = -> next++
        return []
            "for of reuse keys"
            {}
            template (items) ->
                return []
                    for key, value of items
                        { id: nextId(), key: key, value: value }
            {alpha:1,beta:2,charlie:3}
            {beta:3,charlie:undefined}
            [{id:0,key:'alpha',value:1},{id:1,key:'beta',value:3}]

export
    test:
        for [name, thisArg, templateType,argument,patch,expected] in templates if expected?
            [name]: do (thisArg, templateType, argument, patch, expected) ->
                return (done) ->
                    let template = templateType.template.call(thisArg, argument)
                    const checkIfDone (check) ->
                        if JSON.stringify(check) is JSON.stringify(expected)
                            template.deactivate()
                            done()
                    template.activate()
                    (template.watch)
                        (value) ->
                            checkIfDone(value)
                            (ion.observe)
                                value
                                (changes) ->
                                    checkIfDone(value)
                    ion.patch(argument, patch)
