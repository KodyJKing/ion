{
    function e(op, args) {
        if (args == null)
          args = [];
        operation = ops[op];
        if (operation == null)
            throw new Error("operation not found: " + op);
        return {op:operation,args:args};
    }
    function f(array) {
        return array.reduce(function(a,b){
            if (Array.isArray(a)) a = f(a);
            if (Array.isArray(b)) b = f(b);
            return a.concat(b);
        }, '')
    }
    function joinLeft(head, tail) {
        var result = head;
        for (var i = 0; i < tail.length; i++) {
            var step = tail[i];
            step.args.unshift(result);
            result = step;
        }
        return result;
    }
    var core = require('./core');
    var ops = require('./Operation');
}

//  new code
start = eof { return [] }
      / newScopeStatements

definition = eol? s a:id s "=" s b:lineExpression eol? { return e("=", [a,b]) }
statement = eol? a:(if / for / assignment / lineExpression) eol? { return a }
if = s "if" break s a:singleLineExpression indent b:statement+ outdent c:else?
    { return e("if", isEmpty(c) ? [a,b] : [a,b,c]) }
else = s "else" break s a:(singleLineExpression / eol { return "" }) indent b:statement+ outdent
    { return isEmpty(a) ? b : e("if", [a,b]) }
for = s "for" break s a:singleLineExpression indent b:newScopeStatements outdent { return e("for", [a,b]) }
assignment = s id:key s ":" s a:lineExpression { return e(":", [id,a]) }
lineExpression = multiLineExpression / singleLineExpression
multiLineExpression = multilineString / multilineObject
multilineObject = type:(singleLineExpression / eol {return null}) indent s:statement+ outdent
{
    return e("object", [type,s])
}
singleLineExpression = a:(list / e) eol { return a }
newScopeStatements = a:definition* b:statement+ { return a.concat(b) }
e "expression" = s a:conditional s { return a }

//  statements
list = a:e b:(s ',' s c:e { return c })+ { b.unshift(a); return e("list", b) }

//  multi line strings
multilineString = "\"\"" eol content:multilineStringContent { return core.unindent(f(content)) }
multilineStringLine = !indent !outdent (!eol .)* eol
multilineStringContent = indent content:(multilineStringLine / multilineStringContent)* outdent { return content }

//  path
path = a:firstStep b:step* { return joinLeft(a, b) }
firstStep = literal / ref / group
step = children / propertyGet / predicate / propertyIndexer / functionCall
predicate = "{" s a:e s "}" { return e("predicate", [a]) }
propertyGet = "." a:id { return e("get", [a]) }
propertyIndexer = "[" s a:e s "]" { return e("get", [a]) }
children = "." s "*" { return e("children", []) }
functionCall = a:args { return e("call", [a]) }
args = "(" s ")" { return [] }
     / "(" a:e ")" { return [a] }
     / "(" a:list ")" { return a }

//  objects and arrays
object = id? eol indent assignment+ outdent
indent "INDENT" = s token:"{{{{" eol
{
  if (token != core.indentToken)
    throw new Error(token + " != " + core.indentToken);
  return token;
}
outdent "OUTDENT" = s token:"}}}}" eol
{
  if (token != core.outdentToken)
    throw new Error(token + " != " + core.outdentToken);
  return token;
}

//  ops
conditional
  = a:or s "?" s b:conditional s ":" s c:conditional { return e("?", [a,b,c]) }
  / a:or s op:"?" s b:conditional  { return e(op, [a,b]) }
  / or
or
  = left:and s op:"||" s right:or { return e(op, [left,right]) }
  / and
and
  = left:equality s op:"&&" s right:and { return e(op, [left,right]) }
  / equality
equality
  = left:relational s op:("==" / "!=") s right:equality { return e(op, [left,right]) }
  / relational
relational
  = left:additive s op:("<=" / ">=" / "<" / ">") s right:relational { return e(op, [left,right]) }
  / additive
additive
  = left:multiplicative s op:("+" / "-") s right:additive { return e(op, [left,right]) }
  / multiplicative
multiplicative
  = left:unary s op:("*" / "/" / "%") s right:multiplicative { return e(op, [left,right]) }
  / unary
unary
  = op:("!" / "-") s right:primary
  / primary
primary = path / group / literal
group = '(' s a:e s ')' { return a }

//  references
ref = null / global / root / ancestor / idref
null = "null" break { return null }
global = '$' break { return e("global") }
root = ('@' / 'this') break { return e("root") }
ancestor = a:('.'+) { return e("ancestor", [f(a).length]) }
idref = a:id { return e("ref", [a]) }
id = a:([a-zA-Z_][a-zA-Z_0-9]*) { return f(a) }
key = id / string

//  literals
literal = number / boolean / string
d "digit" = [0-9]
number = a:([+-]? d+ ([eE] [+-]? d+)?) break { return parseFloat(f(a)) }
integer = a:([+-]? d+) break { return parseInt(f(a)) }
boolean = "true" break { return true } / "false" break { return false }
h "hex" = [0-9a-fA-F]
string = string1 / string2
string1 = '"' chars:(('\\' (["\\\/bfnrt] / ('u' h h h h))) / [^"\\\r\n])* '"'
        { return eval('"' + f(chars) + '"') }
string2 = "'" chars:(('\\' (['\\\/bfnrt] / ('u' h h h h))) / [^'\\\r\n])* "'"
        { return eval("'" + f(chars) + "'") }
raw = chars:(!eol .)* { return e("raw", [f(chars)]) }

//  breaks
s "space" = " "*
break = ![0-9a-zA-Z]
eol "end of line" = s eof / (s ("\r\n" / "\r" / "\n"))+
eof "end of file" = !.
