
const
    makePrettyError = (e, source, id) ->
        if typeof e.line is 'number' and typeof e.column is 'number' and e.line > 0 and e.column > 0
            let line = source.split('\n')[e.line - 1]
            let caret = '^'
            for let i = 1; i < e.column; i++
                caret = ' ' + caret
            let newMessage = "{{id ? '(anonymous)'}}:{{e.line}}:{{e.column}}: {{e.message}}\n{{line}}\n{{caret}}"
            e.originalMessage = e.message
            e.message = newMessage
            e.stack = newMessage # + '\n' + e.stack

export const
    parse = (content, options = {}) ->
        options.generate = false
        return compile(content, options)

    compile = (content, options = {}) ->
        options.loc ?= true
        const
            preprocessor = import './preprocessor'
            parser = import './parser'
            postprocessor = import './postprocessor'
            escodegen = import 'escodegen'
        let
            sourceMapping = {}
            result = preprocessor.preprocess(content, sourceMapping)
            preprocessed = result
            sourceLocationsFixed = false
        try
            result = parser.parse(result, options ? {})
            result = preprocessor.fixSourceLocations(result, sourceMapping)
            sourceLocationsFixed = true
            if options.postprocess isnt false
                result = postprocessor.postprocess(result, options)
                if options?.generate isnt false
                    result = escodegen.generate(result)
        catch e
            if not sourceLocationsFixed
                preprocessor.fixSourceLocation(e, sourceMapping)
            # console.log('-Preprocessed--------------------------------------------')
            # console.log(preprocessed)
            makePrettyError(e, content, options.id)
            throw e
        return result
