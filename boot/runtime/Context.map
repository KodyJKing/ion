{"version":3,"sources":["Context.ion"],"names":["ion","Factory","Literal","Context","constructor","parent","output","variables","root","properties","newContext",{"type":"Identifier","name":"newContext","loc":{"start":{"line":18,"column":8,"fixed":true},"end":{"line":18,"column":18,"fixed":true}}},"createRuntime","node","get","name","variable","getVariable","Error","value","watcher","a","watch","unwatch","context","global","cachedGlobals","globals","setVariableFromAst","setVariableExpression","setVariableLiteral","expression"],"mappings":"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","sourcesContent":["\nconst\n    ion = import '../'\n    Factory = import './Factory'\n    Literal = import './Literal'\n\nexport class Context\n    constructor: (parent, output) ->\n        # the output object that values are written to\n        @output = output\n        # parent is either null or another Context\n        @parent = parent\n        # an object that maps variable names to variable expressions\n        @variables = {}\n        # store a reference to the root context\n        @root = @parent?.root ? @\n    properties:\n        newContext: (output = @output) -> new Context(@, output)\n        createRuntime: (node) -> Factory.createRuntime(@, node)\n        get: (name) ->\n            let variable = @getVariable(name)\n            if not variable?\n                throw new Error(\"Variable not found: '{{name}}'\")\n            let value = variable.value\n            if value is undefined\n                let watcher = (a) ->\n                    if a isnt undefined\n                        value = a\n                variable.watch(watcher)\n                variable.unwatch(watcher)\n            return value\n        getVariable: (name) ->\n            let context = @, value\n            while context?\n                let variable = context.variables[name]\n                if variable?\n                    return variable\n                context = context.parent\n            # if the variable is not defined by us then it is probably a global variable.\n            # we do however require that it be a globally defined variable, otherwise we throw an error.\n            value = global[name]\n            if value is undefined\n                throw new Error(\"Variable not found: '{{name}}'\")\n            # global values are considered to be constants.\n            # we could consider caching these values within the context.\n            let cachedGlobals = @root.globals ?= {}\n            return cachedGlobals[name] ?= new Literal({value})\n        setVariableFromAst: (name, node) ->\n            if name?\n                @setVariableExpression(name, @createRuntime(node))\n        setVariableLiteral: (name, value) ->\n            if name?\n                @setVariableExpression(name, new Literal({value}))\n        setVariableExpression: (name, expression) ->\n            if name?\n                return @variables[name] = expression\n"]}