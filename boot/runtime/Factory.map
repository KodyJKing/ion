{"version":3,"sources":["Factory.ion"],"names":["ion","Literal","Expression","Factory","properties","runtime","createRuntime","writable","value",{"type":"Identifier","name":"value","loc":{"start":{"line":12,"column":12,"fixed":true,"source":"ion/runtime/Factory.ion"},"end":{"line":12,"column":17,"fixed":true,"source":"ion/runtime/Factory.ion"}}},"context","ast","clone","factory","type","canCache","toCode","left","operator","right","JSON","stringify","lookup","VariableDeclaration","ThisExpression","expression","getVariable","deep","Identifier","name","Function","Template","Property","IfStatement","BlockStatement","ReturnStatement","ObjectExpression","ArrayExpression","ExpressionStatement","ForOfStatement","ForInStatement","MemberExpression","object","property","computed","CallExpression","NewExpression","UnaryExpression","evaluate","a","ConditionalExpression","BinaryExpression","getFactory","step","key","values","nodeValue","next","constructor","code","_toCode","Object","defineProperty","Error","test"],"mappings":"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","sourcesContent":["const ion = import '../'\nconst Literal = import './Literal'\nconst Expression = import './Expression'\n\nclass Factory\n    properties:\n        runtime: './OperationExpression'\n        # creates a runtime construct from this operation\n        # with the specified context and AST node\n        createRuntime:\n            writable: true\n            value: (context, ast) ->\n                let properties = ion.clone(ast)\n                properties.context = context\n                properties.factory = @\n                let type = import @runtime\n                return new type(properties)\n                    ast: ast\n        canCache:\n            writable: true\n            value: (ast) -> false\n        toCode:\n            writable: true\n            value: (ast) ->\n                if ast.type is 'BinaryExpression'\n                    return toCode(ast.left) + ast.operator + toCode(ast.right)\n                return \"({{JSON.stringify(ast)}})\"\n\nconst lookup =\n    type:\n        VariableDeclaration: new Factory\n            runtime: './VariableDeclaration'\n        ThisExpression: new Factory\n            createRuntime: (context, ast) ->\n                let expression = context.getVariable('this')\n                if ast.deep\n                    expression.deep = true\n                return expression\n            toCode: (ast) -> 'this'\n        Identifier: new Factory\n            createRuntime: (context, ast) ->\n                let expression = context.getVariable(ast.name)\n                if ast.deep\n                    expression.deep = true\n                return expression\n            canCache: (ast) -> true\n            toCode: (ast) -> ast.name\n        Function: new Factory\n            createRuntime: (context, ast) ->\n                let value = ast.value\n                if ast.context\n                    value = value(context)\n                return new Literal({value:value})\n        Template: new Factory\n            runtime: './Template'\n        Literal: new Factory\n            runtime: './Literal'\n            canCache: (ast) -> true\n            toCode: (ast) -> JSON.stringify(ast.value)\n        Property: new Factory\n            runtime: './Property'\n        IfStatement: new Factory\n            runtime: './IfStatement'\n        BlockStatement: new Factory\n            runtime: './BlockStatement'\n        ReturnStatement: new Factory\n            runtime: './ReturnStatement'\n        ObjectExpression: new Factory\n            runtime: './ObjectExpression'\n        ArrayExpression: new Factory\n            runtime: './ArrayExpression'\n        ExpressionStatement: new Factory\n            runtime: './ExpressionStatement'\n        ForOfStatement: new Factory\n            runtime: './ForInOfStatement'\n        ForInStatement: new Factory\n            runtime: './ForInOfStatement'\n        MemberExpression: new Factory\n            runtime: './MemberExpression'\n            canCache: (ast) -> canCache(ast.object) and canCache(ast.property)\n            toCode: (ast) ->\n                if ast.computed\n                    return \"{{toCode(ast.object)}}[{{toCode(ast.property)}}]\"\n                else\n                    return \"{{toCode(ast.object)}}.{{toCode(ast.property)}}\"\n        CallExpression: new Factory\n            runtime: './CallExpression'\n        NewExpression: new Factory\n            runtime: './CallExpression'\n        UnaryExpression:\n            operator:\n                \"!\": new Factory\n                    evaluate: (a) -> not a\n                \"typeof\": new Factory\n                    evaluate: (a) -> typeof a\n                \"void\": new Factory\n                    evaluate: (a) -> void a\n                \"-\": new Factory\n                    evaluate: (a) -> - a\n                \"+\": new Factory\n                    evaluate: (a) -> + a\n                \"~\": new Factory\n                    evaluate: (a) -> ~ a\n                \"?\": new Factory\n                    evaluate: (a) -> a?\n        ConditionalExpression: new Factory\n            runtime: './ConditionalExpression'\n            # unlike in imperative code, both consequent and alternate are always evaluated\n            # evaluate: (test, consequent, alternate) -> test ? consequent : alternate\n        BinaryExpression:\n            operator:\n                \"*\": new Factory\n                    evaluate: (left, right) -> left * right\n                \"/\": new Factory\n                    evaluate: (left, right) -> left / right\n                \"%\": new Factory\n                    evaluate: (left, right) -> left % right\n                \"+\": new Factory\n                    evaluate: (left, right) -> left + right\n                \"-\": new Factory\n                    evaluate: (left, right) -> left - right\n                \"&&\": new Factory\n                    evaluate: (left, right) -> left and right\n                \"||\": new Factory\n                    evaluate: (left, right) -> left or right\n                \"&\": new Factory\n                    evaluate: (left, right) -> left & right\n                \"|\": new Factory\n                    evaluate: (left, right) -> left | right\n                \"==\": new Factory\n                    evaluate: (left, right) -> `left == right`\n                \"!=\": new Factory\n                    evaluate: (left, right) -> `left != right`\n                \"===\": new Factory\n                    evaluate: (left, right) -> left is right\n                \"!==\": new Factory\n                    evaluate: (left, right) -> left isnt right\n                \"<\": new Factory\n                    evaluate: (left, right) -> left < right\n                \">\": new Factory\n                    evaluate: (left, right) -> left > right\n                \"<=\": new Factory\n                    evaluate: (left, right) -> left <= right\n                \">=\": new Factory\n                    evaluate: (left, right) -> left >= right\n\nconst getFactory(ast, step = lookup) ->\n    for key, values of step\n        let nodeValue = ast[key]\n        let next = values[nodeValue]\n        if next?\n            if next.constructor is Factory\n                return next\n            return getFactory(ast, next)\n    return null\n\nexport const\n    canCache = (ast) ->\n        if ast?\n            let factory = getFactory(ast)\n            if factory?\n                return factory.canCache(ast)\n        return false\n    toCode = (ast) ->\n        if ast?\n            let code = ast._toCode\n            if not code?\n                let factory = getFactory(ast)\n                if factory?\n                    code = factory.toCode(ast)\n                if code? and typeof ast is 'object'\n                    Object.defineProperty(ast, '_toCode', {value:code})\n            return code\n        return JSON.stringify(ast)\n    createRuntime = (context, ast) ->\n        if typeof ast?.type isnt 'string'\n            ast =\n                type: 'Literal'\n                value: ast\n        let factory = getFactory(ast)\n        if not factory?\n            throw new Error(\"Factory not found for ast:\\n{{JSON.stringify(ast, null, '  ')}}\")\n        return factory.createRuntime(context, ast)\n    test = ->\n        # try to get a factory for < operation\n        let factory = getFactory(\n            {}\n                type: 'BinaryExpression'\n                operator: '>'\n                left:\n                    type: 'Literal'\n                    value: 1\n                right:\n                    type: 'Literal'\n                    value: 2\n        )\n        assert factory is lookup.type.BinaryExpression.operator[\">\"]\n        assert lookup.type.BinaryExpression.operator[\">\"]?\n"]}