{"version":3,"sources":["ForInOfStatement.ion"],"names":["ion","Statement","DynamicExpression","ForInOfStatement","properties","toKey",{"type":"Identifier","name":"toKey","loc":{"start":{"line":8,"column":8,"fixed":true,"source":"ion/runtime/ForInOfStatement.ion"},"end":{"line":8,"column":13,"fixed":true,"source":"ion/runtime/ForInOfStatement.ion"}}},"name","type","parseInt","forEach","collection","callback","key","length","value","activate","statements","valueName","left","declarations","id","keyName","collectionExpression","context","createRuntime","right","unobserveExpression","observe","collectionWatcher","unobserveCollection","removeItem","addItem","collectionObserver","applyChanges","bind","deactivate","keyToUnicodeChar","String","fromCharCode","keyCache","keyCacheCount","getOrderForKey","order","hasOwnProperty","Error","newContext","setVariableExpression","statement","body","disposeStatement","remove","removeStatement","summarize","changes","ignoreProperty","map","Map","object","oldValue","has","set","change","get","array","newValue","push","originalChanges","getRecycleKey","canRecycle","recyclableStatements","activateStatements","rkey","contextsToUpdateOrder","variables","setValue","delete","oldOrder","newOrder","inserter","update"],"mappings":"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","sourcesContent":["const\n    ion = import '../'\n    Statement = import './Statement'\n    DynamicExpression = import './DynamicExpression'\n\nexport class ForInOfStatement extends Statement\n    properties:\n        toKey: (name) ->\n            if @type is 'ForOfStatement'\n                return parseInt(name)\n            else\n                return name\n        forEach: (collection, callback) ->\n            # console.log('forEach', collection)\n            if @type is 'ForOfStatement'\n                for let key = 0; key < collection.length; key++\n                    let value = collection[key]\n                    callback(key, value)\n            else\n                for key, value of collection\n                    callback(key, value)\n        activate: ->\n            super\n\n            if not @statements?\n                @statements = {}            \n                @valueName = @left.declarations[@type is 'ForOfStatement' ? 0 : 1]?.id.name\n                @keyName = @left.declarations[@type is 'ForOfStatement' ? 1 : 0]?.id.name\n\n            # we must create new contexts for every item in the list thingy.\n            @collectionExpression ?= @context.createRuntime(@right)\n            @unobserveExpression = @collectionExpression.observe(\n                @collectionWatcher ?= (collection) =>\n                    # console.log('collectionWatcher', collection)\n                    if @collection isnt collection\n                        @unobserveCollection?()\n                        if @collection?\n                            #   we cannot simply iterate the this.collection since it's values may have changed\n                            #   this could result in orphaned statements.  We must remove all current statements.\n                            for key of @statements\n                                @removeItem(key)\n                        @unobserveCollection = null\n                        @collection = collection\n                        if @collection?\n                            @forEach(\n                                @collection\n                                (key, value) =>\n                                    @addItem(key, value)\n                            )\n                            @unobserveCollection = ion.observe(@collection, (@collectionObserver ?= @applyChanges.bind(@)))\n            )\n        deactivate: ->\n            super\n            @collectionWatcher?(undefined)\n            @unobserveExpression()\n            @unobserveCollection?()\n        keyToUnicodeChar: (key) ->\n            if typeof key is 'number'\n                return String.fromCharCode(48 + key)\n            else\n                # we will cache a monotonically increasing index for this key\n                @keyCache ?= {}\n                @keyCacheCount ?= 0\n                return @keyCache[key] ?= String.fromCharCode(48 + @keyCacheCount++)\n        getOrderForKey: (key) -> @order + @keyToUnicodeChar(key)\n        addItem: (key, value, activate = true) ->\n            # console.log('addItem', key, value, activate)\n            if @statements.hasOwnProperty(key)\n                throw new Error(\"There should not be a current statement for this key: \" + key)\n            if value isnt undefined\n                # see if there is a cached statement with that value\n                let order = @getOrderForKey(key)\n                let context = @context.newContext(undefined, order)\n                if @valueName?\n                    context.setVariableExpression(@valueName, new DynamicExpression({value:value}))\n                if @keyName?\n                    context.setVariableExpression(@keyName, new DynamicExpression({value:key}))\n                let statement = context.createRuntime(@body)\n                @statements[key] = statement\n                if activate\n                    statement.activate()\n                return statement\n        removeItem: (key, value) ->\n            # console.log('removeItem', key, value)\n            let statement = @statements[key]\n            if statement?\n                @disposeStatement(statement)\n            delete @statements[key]\n            return statement\n        disposeStatement: (statement) ->\n            # see if there is a remove function to call\n            if @remove?\n                let removeStatement = statement.context.createRuntime(@remove)\n                removeStatement.activate()\n                # now have to immediately deactivate the remove statement\n                removeStatement.deactivate()\n            statement.deactivate()\n        summarize: (changes) ->\n            let ignoreProperty = (name) =>\n                if not name?\n                    return true\n                if name[0] is '_'\n                    return true\n                if name is 'length' and @type is 'ForOfStatement'\n                    return true\n                return false\n            let map = new Map\n            for {type,object,name,oldValue} in changes\n                if object is @collection # if we are getting a late message from the old collection, disregard\n                    if not ignoreProperty(name)\n                        if not map.has(name)\n                            map.set(name, {type,object,name,oldValue})\n                        else\n                            let change = map.get(name)\n                            # update the type.\n                            change.type = type\n            let array = []\n            map.forEach(\n                (change, name, object)->\n                    let newValue = change.object[name]\n                    if newValue isnt change.oldValue\n                        delete change.object\n                        array.push(change)\n            )\n            return array\n        applyChanges: (changes) ->\n            let originalChanges = changes\n            # prune the change messages down\n            changes = @summarize(changes)\n            if changes.length is 0\n                return\n\n            let getRecycleKey = (key, value) => @type is 'ForOfStatement' ? value : key\n\n            # we can only use the fast recycle method IF there are no duplicate keys in the changes, and none are null\n            let canRecycle = true\n            #   since we implemented result sort ordering, we can now always recycle.\n\n            # if canRecycle\n            #     let checkRecycleKeys = new Map\n            #     for {name, oldValue} in changes\n            #         let checkKey = getRecycleKey(name, oldValue)\n            #         if checkKey? and checkRecycleKeys.has(checkKey)\n            #             canRecycle = false\n            #             break\n\n            if not canRecycle\n                for {name,type,oldValue} in changes\n                    let newValue = @collection?[name]\n                    let key = @toKey(name)\n                    if oldValue isnt undefined\n                        @removeItem(key, oldValue)\n                    if newValue isnt undefined\n                        @addItem(key, newValue)\n            else\n                let recyclableStatements = new Map\n                let activateStatements = []\n                for {name,oldValue} in changes\n                    let key = @toKey(name)\n                    if oldValue isnt undefined\n                        let rkey = getRecycleKey(key, oldValue)\n                        let statement = @statements[key]\n                        if statement?\n                            delete @statements[key]\n                            recyclableStatements.set(rkey, statement)\n\n                let contextsToUpdateOrder = [] # [key,context]\n\n                for {name,oldValue} in changes\n                    let newValue = @collection?[name]\n                    let key = @toKey(name)\n                    if newValue isnt undefined\n                        let rkey = getRecycleKey(key, newValue)\n                        let statement = recyclableStatements.get(rkey)\n                        # let statement = null\n                        if statement?\n\n                            # # now update any recycled statements\n                            # for key, statement of recycledStatementsToUpdate\n                            let context = statement.context\n                            if @type is 'ForOfStatement'\n                                if @keyName?\n                                    context.variables[@keyName].setValue(key)\n                                # we HAVE to wait until after we remove all old statements before updating the recycled statements\n                                # otherwise, we might update a statements insertions to a position still occupied by an old statement\n                                contextsToUpdateOrder.push([key,context])\n                            else\n                                if @valueName?\n                                    context.variables[@valueName].setValue(newValue)\n\n                            @statements[key] = statement\n                            recyclableStatements.delete(rkey)\n                        else\n                            statement = @addItem(key, newValue, false)\n                            if statement?\n                                activateStatements.push(statement)\n\n                # it's important that old statements are deactivated BEFORE new statements are activated\n\n                # recyclableStatements are deactivated.\n                recyclableStatements.forEach(\n                    (statement) =>\n                        @disposeStatement(statement)\n                )\n\n                # update recycled context orders\n                for [key,context] in contextsToUpdateOrder\n                    # We must now also update the new order on the context, since it may cause insertion locations to shift\n                    let oldOrder = context.order\n                    let newOrder = @getOrderForKey(key)\n                    # console.log(\"{{oldOrder}} ----> {{newOrder}}\")\n                    context.order = @getOrderForKey(key)\n                # all of these contexts share the same inserter, which is the same as the one in our context.  Now we update all orders simultaneously.\n                @context.inserter?.update()\n\n                # activate new statements\n                for statement in activateStatements\n                    statement.activate()\n\n"]}