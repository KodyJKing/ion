{"version":3,"sources":["common.ion"],"names":["ion","lineDelimiter","isEmpty",{"type":"Identifier","name":"isEmpty","loc":{"start":{"line":5,"column":4,"fixed":true},"end":{"line":5,"column":11,"fixed":true}}},"s","length","trim","indentToken","outdentToken","splitLines","split","joinLines","array","join","getIndent","regex","exec","Number","MAX_VALUE","unindentString","sourceMapping","lines","trimRight","minIndent","unindentLines","columnOffset","getMinIndent","line","Math","min","i","substring"],"mappings":"aAAA;AACA,IACIA,GAAA,G,OAAM,CAAO,KAAP,CADV,EAEIC,aAAA,GAAgB,IAFpB,EAGIC,OAAA,GAAUC,UAACC,CAADD,E;eAAO,C,CAAIC,C,SAAJ,IAAUA,CAAA,CAAEC,MAAF,KAAY,CAAtB,I,CAA2BD,CAAA,CAAEE,I,WAAFF,CAAA,CAAEE,IAAF,GAAUD,M,UAAV,KAAoB,C;KAHpE,CADA;AAMO,IACHE,WAAA,G,QAAAA,W,GAAc,MADX,EAEHC,YAAA,G,QAAAA,Y,GAAe,MAFZ,EAGHC,UAAA,G,QAAAA,U,GAAaN,UAACC,CAADD,E;eAAOC,CAAA,CAAEM,KAAF,CAAQT,aAAR,C;KAHjB,EAIHU,SAAA,G,QAAAA,S,GAAYR,UAACS,KAADT,E;eAAWS,KAAA,CAAMC,IAAN,CAAWZ,aAAX,C;KAJpB,EAKHa,SAAA,G,QAAAA,S,GAAYX,UAACC,CAADD,EAAIY,KAAJZ,EAChB;AAAA,QAAQY,KAAA,GAAAA,K,WAAAA,K,GAAS,SAAT,CAAR;AAAA,QACQ,O,CAAOA,KAAA,CAAMC,IAAN,CAAWZ,CAAX,C,WAAAW,KAAA,CAAMC,IAAN,CAAWZ,CAAX,EAAe,CAAf,EAAkBC,M,qBAAlBU,KAAA,CAAMC,IAAN,CAAWZ,CAAX,EAAe,CAAf,EAAkBC,M,GAASY,MAAA,CAAOC,SAAzC,CADR;AAAA,KANO,EAQHC,cAAA,G,QAAAA,c,GAAiBhB,UAACC,CAADD,EAAIiB,aAAJjB,EACrB;AAAA,QAAQ,IAAIkB,KAAA,GAAQZ,UAAA,CAAWL,CAAA,CAAEkB,SAAF,EAAX,CAAZ,CAAR;AAAA,QACQ,IAAIC,SAAA,GAAYC,aAAA,CAAcH,KAAd,CAAhB,CADR;AAAA,QAEQ,IAAGD,a,QAAH,EACR;AAAA,YAAYA,aAAA,CAAcK,YAAd,GAA6BF,SAA7B,CAAZ;AAAA,SAHA;AAAA,QAIQ,OAAOZ,SAAA,CAAUU,KAAV,CAAP,CAJR;AAAA,KATO,EAcHK,YAAA,G,QAAAA,Y,GAAevB,UAACkB,KAADlB,EAAQY,KAARZ,EACnB;AAAA,QAAQ,IAAIoB,SAAA,GAAYN,MAAA,CAAOC,SAAvB,CAAR;AAAA,Q,sBACoBG,K,eACpB;AAAA,Y,IADYM,I,GAAQN,K,KACpB;AAAA,YAAY,IAAG,OAAOM,IAAP,KAAe,QAAf,IAA4B,CAAIzB,OAAA,CAAQyB,IAAR,CAAnC,EACZ;AAAA,gBAAgBJ,SAAA,GAAYK,IAAA,CAAKC,GAAL,CAASN,SAAT,EAAoBT,SAAA,CAAUa,IAAV,EAAgBZ,KAAhB,CAApB,CAAZ,CAAhB;AAAA,aADA;AAAA,SAFA;AAAA,QAIQ,OAAOQ,SAAP,CAJR;AAAA,KAfO,EAoBHC,aAAA,G,QAAAA,a,GAAgBrB,UAACkB,KAADlB,EACpB;AAAA,QAAQ,IAAIoB,SAAA,GAAYG,YAAA,CAAaL,KAAb,CAAhB,CAAR;AAAA,Q,wBACuBA,K,gBACvB;AAAA,Y,IADkBS,C,OAClB;AAAA,Y,IADYH,I,GAAWN,K,MACvB;AAAA,YAAY,IAAG,OAAOM,IAAP,KAAe,QAAlB,EACZ;AAAA,gBAAgBN,KAAA,CAAMS,CAAN,IAAW5B,OAAA,CAAQyB,IAAR,IAAgB,EAAhB,GAAqBA,IAAA,CAAKI,SAAL,CAAeR,SAAf,CAAhC,CAAhB;AAAA,aADA;AAAA,SAFA;AAAA,QAIQ,OAAOA,SAAP,CAJR;AAAA,KArBO","sourcesContent":["\r\nconst\r\n    ion = import '../'\r\n    lineDelimiter = '\\n'\r\n    isEmpty = (s) -> not s? or s.length is 0 or s.trim?().length is 0\r\n\r\nexport const\r\n    indentToken = '{{{{'\r\n    outdentToken = '}}}}'\r\n    splitLines = (s) -> s.split(lineDelimiter)\r\n    joinLines = (array) -> array.join(lineDelimiter)\r\n    getIndent = (s, regex) ->\r\n        regex ?= /^([ ]*)/\r\n        return regex.exec(s)?[1].length ? Number.MAX_VALUE\r\n    unindentString = (s, sourceMapping) ->\r\n        let lines = splitLines(s.trimRight())\r\n        let minIndent = unindentLines(lines)\r\n        if sourceMapping?\r\n            sourceMapping.columnOffset = minIndent\r\n        return joinLines(lines)\r\n    getMinIndent = (lines, regex) ->\r\n        let minIndent = Number.MAX_VALUE\r\n        for line in lines\r\n            if typeof line is 'string' and not isEmpty(line)\r\n                minIndent = Math.min(minIndent, getIndent(line, regex))\r\n        return minIndent\r\n    unindentLines = (lines) ->\r\n        let minIndent = getMinIndent(lines)\r\n        for line, i in lines\r\n            if typeof line is 'string'\r\n                lines[i] = isEmpty(line) ? '' : line.substring(minIndent)\r\n        return minIndent\r\n"]}